<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Load-Duration Curve (Percentage of Time vs Demand)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 1rem;
    }
    #container {
      width: 100%;
      max-width: 800px;
      height: 500px;
      margin: auto;
      display: none; /* hidden until data loads */
    }
    #loadingMessage {
      text-align: center;
      font-style: italic;
      margin-top: 2rem;
      color: #666;
    }
    #errorMessage {
      text-align: center;
      color: red;
      margin-top: 2rem;
      display: none;
    }
  </style>
</head>
<body>
  <h2>Facility MDP1: Load-Duration Curve (April 2025)</h2>
  <div id="loadingMessage">Loading demand data…</div>
  <div id="errorMessage"></div>
  <div id="container"></div>

  <!-- Highcharts CDN -->
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // ← Replace <PROXY_URL> with your actual proxy:
      const proxyUrl = "https://load-proxy.onrender.com/api/demand";

      const loadingEl = document.getElementById("loadingMessage");
      const errorEl = document.getElementById("errorMessage");
      const chartContainer = document.getElementById("container");

      fetch(proxyUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" }
      })
        .then(async (res) => {
          if (!res.ok) {
            const bodyText = await res.text();
            throw new Error(`Proxy returned ${res.status}: ${bodyText}`);
          }
          return res.json();
        })
        .then((graphqlResponse) => {
          // Drill into data
          const services = graphqlResponse.data.facility.mainServices.nodes;
          if (!services || services.length === 0) {
            throw new Error("No mainServices found for facility.");
          }

          const demandNodes = services[0].demand.nodes;
          if (!demandNodes || demandNodes.length === 0) {
            throw new Error("No demand data was returned.");
          }

          // Extract numeric demand values
          const allDemands = demandNodes
            .map(pt => pt.data)
            .filter(val => typeof val === "number");

          if (allDemands.length === 0) {
            throw new Error("Demand array was empty or non-numeric.");
          }

          // Sort descending and compute percent-of-time ≥ each value
          const sorted = allDemands.slice().sort((a, b) => b - a);
          const N = sorted.length;
          const points = sorted.map((d, i) => {
            const pct = (i / N) * 100;
            return [parseFloat(pct.toFixed(2)), parseFloat(d.toFixed(2))];
          });

          // Hide loading & show container
          loadingEl.style.display = "none";
          chartContainer.style.display = "block";

          Highcharts.chart("container", {
            chart: { type: "line", zoomType: "x" },
            title: { text: "April 2025 Load-Duration Curve (MDP1)" },
            xAxis: {
              title: { text: "Percent of Time (%)" },
              labels: { format: "{value}%" },
              min: 0,
              max: 100
            },
            yAxis: { title: { text: "Demand (kW)" } },
            tooltip: {
              headerFormat: "",
              pointFormat:
                "<b>{point.y} kW</b><br>Time ≥ this load: {point.x:.2f}%"
            },
            series: [
              {
                name: "Demand (kW)",
                data: points,
                marker: { enabled: false },
                lineWidth: 1.5
              }
            ],
            credits: { enabled: false }
          });
        })
        .catch(err => {
          console.error(err);
          loadingEl.style.display = "none";
          errorEl.style.display = "block";
          errorEl.innerText = "Error: " + err.message;
        });
    });
  </script>
</body>
</html>
